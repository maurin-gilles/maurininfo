<!DOCTYPE html>
<html lang="en">
<head>
    <title>Maurin Gilles</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta charset="utf-8">
    <meta name="keywords" content="Maurin Gilles, Isima, Informatique, Informaticien, Ingénieur, Etudiant, Stagiaire, Clermont-Ferrand, Développeur">
    <meta name="description" content="Page d'accueil du site web de Maurin Gilles.">
    <link rel="icon" type="image/x-icon" href="./imgs/logo.svg">
    <link rel="stylesheet" type="text/css" href="./styles/styles.css">
    <link rel="stylesheet" type="text/css" href="./styles/responsive.css">
    <script src="./script/script.js"></script>
</head>



<body>
    <nav class="menu-container">
        <!-- burger menu -->
        <input type="checkbox" aria-label="Toggle menu" />
        <span></span>
        <span></span>
        <span></span>

        <!-- logo -->
        <a  href=""class="menu-logo">
            <img src="./imgs/logo.svg" alt="magilles5's logo"/>
        </a>

        <!-- menu items -->
        <div class="menu">
            <ul></ul>
            <ul>
            <li>
                <a href="./index.html">Home</a>
            </li>
            <li>
                <a href="./aboutme.html">About me</a>
            </li>
            <li>
                <a href="./iwashere.html">I was here!</a>
            </li>
            <li>
                <a href="./research.html">Research</a>
            </li>
            <li>
                <a href="./articles.html">Articles</a>
            </li>
            <li>
                <a href="./contact.html">Contact</a>
            </li>
            </ul>
        </div>
    </nav>

    <section class="research_main">
        <div class="cool_text">
            <svg viewBox="0 0 960 180">
              <symbol id="s-text">
                <text text-anchor="middle" x="50%" y="80%">Research</text>
              </symbol>
          
              <g class = "g-ants">
                <use xlink:href="#s-text" class="text-copy"></use>
                <use xlink:href="#s-text" class="text-copy"></use>
                <use xlink:href="#s-text" class="text-copy"></use>
                <use xlink:href="#s-text" class="text-copy"></use>
                <use xlink:href="#s-text" class="text-copy"></use>
              </g>
            </svg>
          </div>

        <section class="intro">
            I aim to do a PhD, so I made this page to gather all the research work I'll do during my internships and within the research initiation program I attend.
            I'm not sure yet of the very field I want to specialise in, but I the subjects I feel drawn to are <b>combinatorial optimisation</b>, <b>very large databases </b>and <b>AI</b>.<br><br>
            My profile is at the crossroads of the maths nerd, the computer nerd, the philosophy nerd and the arts nerd.
            It is useful to fit in various environments, but I feel that bringing original, multilayered approaches to problems can be my strength in research.
            <br><br>
        </section>

        <div class="animated_dashed_line">
            <span></span>
            <span></span>
            <span></span>
            <span></span>
        </div>
        <div></div>

        <section class="research_work">
            <h2>Dynamic query optimisation in data integration systems</h2>

            <p>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                This is the work I began in june 2024 for my research initiation program within the <a href="https://limos.fr/"><b><u>LIMOS</u></b></a>, supervised by <a href="https://limos.fr/detailperson/85"><b><u>Jean-Philippe Gayon</u></b></a> for the general research aspects, and <a href="https://limos.fr/detailperson/501"><b><u>Maxime Buron</u></b></a> for the technial aspects.
                This section will introduce the subject and the first ideas of my work. A work-in-progress paper and some code are available on this <a href="https://gitlab.isima.fr/magilles5/parcours-recherche"><b><u>GitLab repo</u></b></a>.
            </p>

            <h3>Goals</h3>

            <p>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                The problem settles in a big data environment, precisely in <b>data integration systems</b>, whose goal is to provide a homogeneous access to data from different sources.
                A major property of data integration systems is this necessity to work with data sources that evolve indepently, on different formats, with different access times, and a lack of available information about the data.
                This is a key difference with regular DBMS, and it calls for specific optimisation techniques, as it will be introduced in the following paragraphs.
                <br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                Data integration systems follow the goal of DBMS to provide a semantic-oriented access to data, thus answering to human queries through an unified language.
                We chose to focus on the relational model, where queries are parsed as logical expressions over relational algebra.
                An expression answering to a specific query is called "query plan", and each meets several equivalent plans, that produce the same output for the same sources, but make it through a different sequence of operators.
                Though such plans are algebraically similar, the difference between their computing time can be arbitrarily high.
                <br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                The goal of <b>query optimisation</b> is to search for the best, or at least a good enough query plan.
                Some optimisation techniques over some operators are insured to always be optimal.
                It is not the case for joins. They are a major operator in relational algebra and can appear in number in complex queries.
                Unfortunately, their outputs are difficult to predict, they have a huge computing time, and the possibilites to structure them become impossible to explore exhaustively for queries involving many joins.
                <br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                Regular relational DBMS meet this issue by saving information about the data that enables them to make decent predictions on the size of the joins.
                However, this method can't be applied to a data integration problem, because the sources are independent.
                The ideas I am exploring consist in <b>"dynamic"</b> query optimisation. The goal is to start processing a sub-optimal plan, and to switch to a better one during execution thanks to information gained along the way.
                My work can be summarized as the seek of answers to these questions:
                <ul>
                    <li>What sub-optimal plan to start with</li>
                    <li>What information to collect</li>
                    <li>How this information allows computing better plans</li>
                    <li>Is the plan improvement worth the cost of collecting information</li>
                    <li>How to switch plan without losing the results computed so far</li>
                </ul>
            </p>

            <h3>Pipelining joins</h3>

            <p>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                Among the questions set aobve, the first that I have been told to look at was the last one: "How to switch from a plan to another without losing the results computed so far?"
                To begin, we looked only at plans where sources are joined over the same attribute, and forgot all the other operators in the query.
                The hypothesis had been made by Maxime Buron that the "double-pipelined hashjoin", a specific algorithm to process joins, could be benefic in that case.
                I made an implementation of this algorithm on <a href="https://gitlab.inria.fr/cedar/tatooine"><b><u>Tatooine</u></b></a>, a data integration simulation project Maxime had already worked on.
                We improved this implemenatation until it got performances similar to other algorithms, thus justifying that it could be used in pratice.
                <br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                The next step of our work has been to show how this implementation allowed to move from a plan to "neighbor" plans in constant time, under our hypotheses.
                Our idea was to start from a plan, search for better ones among its neighbors, apply the transformation if one is found, and repeat the sequence multiple times.
                This "step-by-step" approach unfortunately proved to be actually very limited in our more recent work.
                However, we still think that double-pipelined hashjoin has properties that can be useful to transfer the work already computed from a plan to another.
                <br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                I made a poster when I reached that point. Some ideas are now deprecated, but the main part of it remains a good introduction to my subject. It can be found <a href="docs/poster.pdf"><b><u>here</u></b></a>.
            </p>

        </section>

    </section>
</body>
</html>
